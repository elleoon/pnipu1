# Команды git

* git help и git help `command` — для вызова встроенной справки по гиту и его конкретным командам
* git init — инициализировать пустой репозиторий в текущей рабочей папке
* git status — просмотреть текущее состояние (статус) репозитория
* git add `filename` / `dirname`— добавить (подготовить) файл/папку для включение в коммит в фиксации в репозитории
* git add --all / git add * — подготовить все файлы для включения в коммит
* git reset `filename` / `dirname` — ислючить файл/папку мз коммита (изменения не будут отслеживаться в репозитории)
* git commit -m "описание коммита" — зафиксировать подготовленные файлы в репозитории (закоммитить)
* git diff `filename` — плсмотреть разницу между текущей версией файла и версией, зафиксированной в последнем коммите. Более сложные случае см. документацию
* git log — история коммитов с пояснениями по каждому из них
* git log --pretty=format:"%h %s" --graph — наглядно отформатированная история с визуализацией дерева (веток) репозитория
* git blame `filename` — выдает все строки файла с указанием коммитов и их авторов
* git branch `new_branch` `source_branch` — создать новую (new) ветку на основе указанной ветки (source)
* git switch `branch_name` — переключиться на указанную ветку
* git checkout -b `new_branch` — создать и сразу переключиться на новую ветку
* git merge `branch_name` — слияние двух веток. Указывается имя той ветки, **которую** мы будем присоединять к **текущей**
> например, git merge dev при нахождении на ветке master присоединит ветку dev к ветке master
* git remote — обеспечивает локальное взаимодействие с удаленным репозиторием (добавление его для работы с ним в локальной среде, удаление ссылки на него из локальной среды, просмотр), см. git help remote
* git remote add [-t <ветка>] [-m <мастер-ветка>] [-f] [--tags/--no-tags] [--mirror=<fetch|push>] <имя> <адрес> — один из комплексных вариантов использования команды
* git remote add <имя> <адрес> — тот вариант, который пригоден для наших задач

> имя удаленного репозитория используется для удобной ссылки на него в вашей локальной среде, оно может быть любым, но должно быть уникальным в рамках ваших локальных сред
> по договоренности чаще всего используется имя `origin` — источник
> если в команде `git remote add` не указана ветка, то используется основная ветка удаленного репозитория (обычно master или main)

* git push <имя/адрес> [<ветка>] — выгрузить текущее состояние локального репозитория (т.е. последний коммит) в указанный удаленный репозиторий
> чаще всего потребуется авторизоваться на соответствующем сервисе и/или использовать учетные данные с этого сервиса при работе с вашим локальным репозиторием
* git fetch <имя удаленного репозитория> — получить все коммиты из удаленного репозитория, НО никак не влиять на состояние локального репозитория
* git pull <имя удаленного репозитория> — комбинация `git fetch` и `git merge`, т.е. получение коммитов из удаленного репозитория И одновременное слияние с текущей локальной веткой

* git clone <адрес (URL)> — создать копию удаленного репозитория по указанному адресу и автоматически переключить созданную копию на master/main (получить рабочую локальную копию любого публичного репозитория)

* git revert <идентификатор коммита> — откатить изменения (undo, Ctrl+Z и т.п.), внесенные предыдущим коммитом без изменения истории коммитов (создается новый коммит, содержащий обращение изменение изменений отменяемого коммита)
* git reset — более мощная версия отката изменений, но также и более опасная. Для наших нужд не рекомендуется, но см. git help reset. Бывает `--soft` и `--hard`

# Полезные заметки
## Статусы файлов
* `U`— Unstaged/Untracked, файлы с такой меткой не отслеживаются, изменения в нем не попадут в репозиторий
* `A` — Added, файл с такой меткой добавлен в индекс и будет включен в следующий коммит / `S` — Staged (подготовленный)
* `M` — Modified, файл, который уже был зафиксирован в репозитории ранее (в предыдущих коммитах), был изменен
* `D` — Deleted, файл, который был зафиксирован в одном из предыдущих коммитов, был удален в текущей версиии. NB~: переименование файла ведет к тому, что старое имя файла помечается как D, а новое — как U.

## Начальная настройка git
* git config --global user.email "you@example.com" — для настроки адреса электронной почты
* git config --global user.name "Ваше Имя" — для настройки имени пользователя/логина

Использование команды без флага `--global` настраивает параметры только в текущем репозитории (удобно, если у вас несколько адресов или юзернеймов)

## Области в репозитории

1. Рабочая директория
2. Область подготовленных файлов (индекс) — то, что пойдет в фиксацию при коммите, содержание будущего коммита
3. HEAD — последний коммит в репозитории, от него рассчитываются другие характеристики состояния коммита. При откате до какого-либо коммита в истории HEAD перемещается на этот коммит. Для нескольких веток репозитория также существуют свои HEADы.

## Ветки

Ветка (branch) — серия последовательно связанных коммитов.

git поддерживает существование в репозитории нескольких веток одновременно. При двух и более ветках хотя бы у 2-х из них должен быть общий источник — коммит, общий для обеих веток. 

Активной в одно и то же время может быть только одна ветка. При переключении веток в рабочей директории заменяется снимок файловой системы, что может привести к потере незаыфиксированных изменений.

# Идентификация коммитов
Для каждого среза файловой системы, подготовленного к фиксации, вычисляется хэш-функция (по умолчанию это SHA-1, с версии 2.29 начат переход на SHA-256)

Чаще всего используются первые 7 символов идентификатора для однозначного определения коммита

# Сборка мусора
Если репозиторий сложен (много файлов, веток, большая история коммитов), индекс репозитория растет, занимает много места. Тогда производится сборка мусора.

При этом просходит замена наиболее старых версий файлов на дельты (см. git diff) между ними и текущими версиями файлов.
